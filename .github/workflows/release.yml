name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write  # Required for creating releases

jobs:
  build-macos:
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: aarch64-apple-darwin
            arch: arm64
            name: Apple Silicon
          - target: x86_64-apple-darwin
            arch: x64
            name: Intel

    runs-on: macos-latest
    name: Build macOS (${{ matrix.name }})

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri

      - name: Install dependencies
        run: npm ci

      - name: Import Apple Developer Certificate
        id: import-cert
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Save keychain path for cleanup step
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_OUTPUT

          # Decode certificate
          echo -n "$APPLE_CERTIFICATE" | base64 --decode -o $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate
          security import $CERTIFICATE_PATH -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Clean up certificate file
          rm -f $CERTIFICATE_PATH

      - name: Build Tauri app (signed, not notarized)
        run: npm run tauri build -- --target ${{ matrix.target }}
        env:
          # Only signing identity - no APPLE_ID/PASSWORD means no notarization
          APPLE_SIGNING_IDENTITY: "Developer ID Application: Piotr Zalewa"

      - name: Find DMG file
        id: find-dmg
        run: |
          DMG_PATH=$(find src-tauri/target/${{ matrix.target }}/release/bundle/dmg -name "*.dmg" | head -1)
          DMG_NAME=$(basename "$DMG_PATH")
          echo "path=$DMG_PATH" >> $GITHUB_OUTPUT
          echo "name=$DMG_NAME" >> $GITHUB_OUTPUT
          echo "Found DMG: $DMG_PATH"

      - name: Create or get release
        id: release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if release exists
          if gh release view ${{ github.ref_name }} --repo ${{ github.repository }} > /dev/null 2>&1; then
            echo "Release exists"
          else
            # Create draft release
            gh release create ${{ github.ref_name }} \
              --repo ${{ github.repository }} \
              --title "HomeKaraoke ${{ github.ref_name }}" \
              --notes "See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for details.

          ## Downloads

          ### macOS
          - **Apple Silicon (M1/M2/M3)**: Download the \`aarch64\` DMG
          - **Intel Macs**: Download the \`x64\` DMG

          â³ *Notarization in progress - DMGs will be updated when complete*

          ### Linux
          - **Ubuntu/Debian**: Download the \`.deb\` package
          - **Fedora/RHEL**: Download the \`.rpm\` package
          - **Other distributions**: Download the \`.AppImage\`" \
              --draft
            echo "Created draft release"
          fi

      - name: Upload signed DMG to release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Upload the signed (not yet notarized) DMG
          gh release upload ${{ github.ref_name }} \
            "${{ steps.find-dmg.outputs.path }}#${{ steps.find-dmg.outputs.name }}" \
            --repo ${{ github.repository }} \
            --clobber

      - name: Notarize app (async with retries)
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "Submitting for notarization..."

          # Submit for notarization and capture submission ID
          SUBMIT_OUTPUT=$(xcrun notarytool submit "${{ steps.find-dmg.outputs.path }}" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait \
            --timeout 30m \
            2>&1) || true

          echo "$SUBMIT_OUTPUT"

          # Check if notarization succeeded
          if echo "$SUBMIT_OUTPUT" | grep -q "status: Accepted"; then
            echo "Notarization successful!"
            echo "NOTARIZATION_SUCCESS=true" >> $GITHUB_ENV
          else
            echo "Notarization failed or timed out - signed DMG is still available"
            echo "NOTARIZATION_SUCCESS=false" >> $GITHUB_ENV
          fi

      - name: Staple notarization ticket
        if: env.NOTARIZATION_SUCCESS == 'true'
        run: |
          # Find the .app inside the DMG to staple
          # First, mount the DMG
          MOUNT_POINT=$(mktemp -d)
          hdiutil attach "${{ steps.find-dmg.outputs.path }}" -mountpoint "$MOUNT_POINT" -nobrowse

          # Find the app
          APP_PATH=$(find "$MOUNT_POINT" -name "*.app" -maxdepth 1 | head -1)
          APP_NAME=$(basename "$APP_PATH")

          # Unmount
          hdiutil detach "$MOUNT_POINT"

          # For DMGs, we staple the DMG itself
          xcrun stapler staple "${{ steps.find-dmg.outputs.path }}"

          echo "Stapled notarization ticket to DMG"

      - name: Upload notarized DMG to release
        if: env.NOTARIZATION_SUCCESS == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Replace with notarized DMG
          gh release upload ${{ github.ref_name }} \
            "${{ steps.find-dmg.outputs.path }}#${{ steps.find-dmg.outputs.name }}" \
            --repo ${{ github.repository }} \
            --clobber

          echo "Uploaded notarized DMG to release"

      - name: Cleanup keychain
        if: always()
        run: |
          KEYCHAIN_PATH="${{ steps.import-cert.outputs.KEYCHAIN_PATH }}"
          if [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi

  build-linux:
    runs-on: ubuntu-22.04
    name: Build Linux

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri

      - name: Install Linux dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            build-essential \
            curl \
            wget \
            file \
            libssl-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libdbus-1-dev \
            pkg-config

      - name: Install npm dependencies
        run: npm ci

      - name: Build Tauri app for Linux
        run: npm run tauri build

      - name: Find built packages
        id: find-packages
        run: |
          DEB_PATH=$(find src-tauri/target/release/bundle/deb -name "*.deb" 2>/dev/null | head -1 || echo "")
          RPM_PATH=$(find src-tauri/target/release/bundle/rpm -name "*.rpm" 2>/dev/null | head -1 || echo "")
          APPIMAGE_PATH=$(find src-tauri/target/release/bundle/appimage -name "*.AppImage" 2>/dev/null | head -1 || echo "")

          # Validate DEB package exists (required)
          if [ -z "$DEB_PATH" ] || [ ! -f "$DEB_PATH" ]; then
            echo "::error::DEB package not found! Build may have failed."
            exit 1
          fi

          echo "deb_path=$DEB_PATH" >> $GITHUB_OUTPUT
          echo "deb_name=$(basename "$DEB_PATH")" >> $GITHUB_OUTPUT

          if [ -n "$RPM_PATH" ] && [ -f "$RPM_PATH" ]; then
            echo "rpm_path=$RPM_PATH" >> $GITHUB_OUTPUT
            echo "rpm_name=$(basename "$RPM_PATH")" >> $GITHUB_OUTPUT
          fi

          if [ -n "$APPIMAGE_PATH" ] && [ -f "$APPIMAGE_PATH" ]; then
            echo "appimage_path=$APPIMAGE_PATH" >> $GITHUB_OUTPUT
            echo "appimage_name=$(basename "$APPIMAGE_PATH")" >> $GITHUB_OUTPUT
          fi

          echo "Found packages:"
          echo "  DEB: $DEB_PATH"
          echo "  RPM: $RPM_PATH"
          echo "  AppImage: $APPIMAGE_PATH"

      - name: Create or get release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if release exists (may already be created by macOS job)
          if gh release view ${{ github.ref_name }} --repo ${{ github.repository }} > /dev/null 2>&1; then
            echo "Release exists"
          else
            # Create draft release
            gh release create ${{ github.ref_name }} \
              --repo ${{ github.repository }} \
              --title "Karaoke ${{ github.ref_name }}" \
              --notes "See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for details." \
              --draft
            echo "Created draft release"
          fi

      - name: Upload DEB to release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload ${{ github.ref_name }} \
            "${{ steps.find-packages.outputs.deb_path }}#${{ steps.find-packages.outputs.deb_name }}" \
            --repo ${{ github.repository }} \
            --clobber

      - name: Upload RPM to release
        if: steps.find-packages.outputs.rpm_path != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload ${{ github.ref_name }} \
            "${{ steps.find-packages.outputs.rpm_path }}#${{ steps.find-packages.outputs.rpm_name }}" \
            --repo ${{ github.repository }} \
            --clobber

      - name: Upload AppImage to release
        if: steps.find-packages.outputs.appimage_path != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload ${{ github.ref_name }} \
            "${{ steps.find-packages.outputs.appimage_path }}#${{ steps.find-packages.outputs.appimage_name }}" \
            --repo ${{ github.repository }} \
            --clobber

  # Publish the draft release after all builds complete
  publish-release:
    needs: [build-macos, build-linux]
    runs-on: ubuntu-latest
    steps:
      - name: Update release notes and publish
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Update release notes to remove "in progress" message
          gh release edit ${{ github.ref_name }} \
            --repo ${{ github.repository }} \
            --notes "See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for details.

          ## Downloads

          ### macOS
          - **Apple Silicon (M1/M2/M3)**: Download the \`aarch64\` DMG
          - **Intel Macs**: Download the \`x64\` DMG

          ### Linux
          - **Ubuntu/Debian**: Download the \`.deb\` package
          - **Fedora/RHEL**: Download the \`.rpm\` package
          - **Other distributions**: Download the \`.AppImage\`"

          # Publish the release
          gh release edit ${{ github.ref_name }} --draft=false --repo=${{ github.repository }}
